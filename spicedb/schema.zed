// Separ Authorization Schema for SpiceDB
// Supports: Workspace-First, Tenant-Later Model
//
// Key concepts:
// - Users can exist without tenants
// - Users own workspaces directly
// - Tenants are only created when domains are claimed
// - After domain claim, tenant governance applies

definition platform {
    relation admin: user | service_account
    relation member: user | service_account
    
    permission manage = admin
    permission view = admin + member
}

definition tenant {
    relation platform: platform
    relation owner: user | service_account
    relation admin: user | service_account | group#member
    relation member: user | service_account | group#member
    
    // Domain that was claimed for this tenant
    // e.g., "acme.com" - all @acme.com users belong to this tenant
    
    permission manage = owner + admin + platform->admin
    permission view = owner + admin + member + platform->admin
    permission create_workspace = owner + admin
    permission manage_users = owner + admin
    permission manage_groups = owner + admin
    permission manage_oauth = owner + admin
    permission view_audit = owner + admin
}

definition workspace {
    // Workspace-First Model:
    // - Personal workspaces: owner is set, tenant is NOT set
    // - Team workspaces: owner is set, tenant is NOT set (until domain claimed)
    // - Organization workspaces: both owner and tenant are set
    relation tenant: tenant
    relation owner: user | service_account
    relation admin: user | service_account | group#member
    relation member: user | service_account | group#member
    relation viewer: user | service_account | group#member
    
    // Permissions work with OR without tenant
    // If no tenant, only direct workspace roles apply
    // If tenant exists, tenant permissions also apply (inheritance)
    permission manage = owner + admin + tenant->manage
    permission view = owner + admin + member + viewer + tenant->manage
    permission create_application = owner + admin + tenant->manage
    permission manage_members = owner + admin
    permission invite = owner + admin
}

definition application {
    relation workspace: workspace
    relation owner: user | service_account
    relation admin: user | service_account | group#member
    relation developer: user | service_account | group#member
    relation viewer: user | service_account | group#member
    
    permission manage = owner + admin + workspace->manage
    permission deploy = owner + admin + developer + workspace->manage
    permission view = owner + admin + developer + viewer + workspace->view
    permission manage_resources = owner + admin
    permission define_permissions = owner + admin
}

definition resource {
    relation application: application
    relation owner: user | service_account
    relation editor: user | service_account | group#member
    relation viewer: user | service_account | group#member
    
    permission manage = owner + application->manage
    permission edit = owner + editor + application->manage
    permission view = owner + editor + viewer + application->view
    permission delete = owner + application->manage
}

definition user {
    relation self: user
    relation tenant: tenant
    
    permission manage = self + tenant->manage_users
    permission view = self + tenant->view
}

definition group {
    relation tenant: tenant
    relation workspace: workspace
    relation owner: user | service_account
    relation admin: user | service_account
    relation member: user | service_account | group#member
    
    permission manage = owner + admin + tenant->manage_groups + workspace->manage
    permission view = owner + admin + member + tenant->view + workspace->view
    permission add_member = owner + admin
    permission remove_member = owner + admin
}

definition service_account {
    relation tenant: tenant
    relation owner: user
    relation admin: user | group#member
    
    permission manage = owner + admin + tenant->manage
    permission use = owner + admin
    permission rotate_credentials = owner + admin
}

definition api_key {
    relation service_account: service_account
    relation creator: user
    
    permission manage = creator + service_account->manage
    permission use = service_account->use
    permission revoke = creator + service_account->manage
}

definition role {
    relation tenant: tenant
    relation creator: user | service_account
    relation assignee: user | service_account | group#member
    
    permission manage = creator + tenant->manage
    permission assign = creator + tenant->manage
    permission view = creator + assignee + tenant->view
}

definition oauth_provider {
    relation tenant: tenant
    relation admin: user | service_account
    
    permission manage = admin + tenant->manage_oauth
    permission view = admin + tenant->view
    permission configure = admin + tenant->manage_oauth
}

definition sync_config {
    relation tenant: tenant
    relation admin: user | service_account
    
    permission manage = admin + tenant->manage
    permission view = admin + tenant->view
    permission trigger = admin + tenant->manage
}

// =============================================================================
// Data Catalog Access Control
// =============================================================================
// Follows the same patterns as Unity Catalog (privilege hierarchy),
// Apache Polaris (catalog roles), and Lakekeeper (OpenFGA grants).
//
// Key design:
// - catalog_path represents a path prefix in the data catalog
// - Grants on a path apply to all resources under that path
// - Workspace role provides a default permission level
// - Per-path grants can elevate or restrict (via denied) access

definition catalog_path {
    // Structural relations
    relation workspace: workspace
    relation parent: catalog_path              // for path hierarchy inheritance
    relation connection: storage_connection     // which connection backs this path
    
    // Direct per-user/group grants on this path
    relation owner: user | service_account
    relation admin: user | service_account | group#member
    relation writer: user | service_account | group#member
    relation reader: user | service_account | group#member
    relation denied: user | service_account | group#member
    
    // Computed permissions (direct grants + workspace role inheritance)
    permission manage = owner + admin + workspace->manage - denied
    permission can_write = owner + admin + writer + workspace->manage + parent->can_write - denied
    permission can_read = owner + admin + writer + reader + workspace->view + parent->can_read - denied
    
    // For SAS vending â€” determines the sp (signed permissions) field
    permission vend_read = can_read - denied
    permission vend_write = can_write - denied
}

definition yekta_resource {
    relation workspace: workspace
    relation catalog_path: catalog_path
    relation owner: user | service_account
    relation editor: user | service_account | group#member
    relation viewer: user | service_account | group#member
    
    permission manage = owner + workspace->manage + catalog_path->manage
    permission write = owner + editor + workspace->manage + catalog_path->can_write
    permission read = owner + editor + viewer + workspace->view + catalog_path->can_read
}

definition storage_connection {
    relation tenant: tenant
    relation workspace: workspace
    relation owner: user | service_account
    relation admin: user | service_account | group#member
    relation user: user | service_account | group#member
    
    // Manage: full control (create, update, delete)
    permission manage = owner + admin + tenant->manage + workspace->manage
    // Use: can use this connection for data access
    permission use = owner + admin + user + tenant->view + workspace->view
    // View: can see connection info (but not secrets)
    permission view = owner + admin + user + tenant->view + workspace->view
    // Get credentials: retrieve decrypted secrets (for authorized services)
    permission get_credentials = owner + admin + tenant->manage + workspace->manage
}
